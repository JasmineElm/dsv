# Databases

As a data scientist, you will often need to work with databases to extract,
transform and load data. In this section, we will introduce you to the basics of
databases and show you how to work with them using SQL.

A database is a collection of data that is stored in a computer system.
Databases allow data to be easily accessed, managed, and updated. Databases are
used in a wide range of applications, from simple contact lists to complex
financial systems.

Databases come in many different forms, but the most common type is a relational
database. In a relational database, data is stored in tables, which are made up
of rows and columns. Each row in a table represents a single record, while each
column represents a different attribute of the record. For example, a table of
customers might have columns for `name`, `address`, and `phone number`.

Relational databases are typically accessed using a language called SQL
(Structured Query Language). SQL is a powerful language that allows you to
query, update, and manage data in a database. There are many _dialects_ of SQL
but the basic syntax is common across all of them; selecting data from a table
will look the same in SQLite as it does in MySQL, for example. The dialects
however have some differences in the advanced features they support, and the way
they handle certain types of data. These more advanced features make dialects
much closer to a fully featured programming language than the basic SQL syntax.

| Flavour       | Description                                                                            | SQL Dialect |
| ------------- | -------------------------------------------------------------------------------------- | ----------- |
| SQLite        | A lightweight, serverless, self-contained, and zero-configuration SQL database engine. | SQLite      |
| MySQL/MariaDB | An open-source relational database management system.                                  | MySQL       |
| PostgreSQL    | An open-source object-relational database system.                                      | PostgreSQL  |
| Oracle        | A commercial relational database management system.                                    | PL/SQL      |
| SQL Server    | A commercial relational database management system from Microsoft                      | T-SQL       |

Despite these dialects, all relational databases share the same concepts and
core functionality. In this section, we will focus on SQLite, a lightweight,
serverless, self-contained, and zero-configuration SQL database engine. SQLite
is arguably the most widely deployed SQL database engine in the world. It is
used in a wide range of applications, from mobile apps to web browsers.

## Relational Database Concepts

Though these concepts are not neccesarily ones that you need to consider every
time you interact with a database, they are useful to know about. They will help
you understand how databases work, and why they are designed the way they are.
This will help you to write more efficient queries, and to understand why some
queries are slow.

### ACID

Relational databases are `write optimised`, meaning that they are designed to be
efficient at writing data to disk. This is because they are designed to store
large amounts of data and to be able to write to that data quickly. Relational
databases are also `ACID` compliant, meaning that they support the following
properties:

- Atomicity: All changes to the database are made as a single unit of work. If
  any part of the transaction fails, the entire transaction is rolled back.
- Consistency: The database is always in a consistent state. This means that the
  database will always be in a valid state, even if a transaction fails.
- Isolation: Transactions are isolated from each other. This means that changes
  made by one transaction are not visible to other transactions until the
  transaction is complete.
- Durability: Changes made to the database are permanent. This means that once a
  transaction is committed, the changes are written to disk and cannot be
  undone.

## Normalisation

Normalisation is something that will have a large impact on your analysis work.
In simple terms, `normalisation` is the process of removing duplicated, or
redundant data from a database. This is done by breaking up the data into
smaller tables, and linking them together using keys. Consider the following
table:

| Name       | Address                                                | Phone Number | Email Address  | Date of Birth |
| ---------- | ------------------------------------------------------ | ------------ | -------------- | ------------- |
| John Smith | 1 Brownberrie Ln, Horsforth, Leeds, Yorkshire LS18 5HD | 01234 567890 | John@email.com | 01/01/1970    |
| Jane Doe   | 1 Brownberrie Ln, Horsforth, Leeds, Yorkshire LS18 5HD | 09876 543210 | Jane@doe.com   | 01/01/1970    |

If John gave us a second email address, we would have to either add a new column
to the table, and _update every row in the table_, or create a second row for
John. If we created a second record for Joh, how would we know which row to use?
A second problem with this would be due to the `atom`ic nature of database
transactions. If we were to update John's email address, no-one would be able to
alter John's name, address, or phone number until the transaction was complete.
This would be a problem if we were to have a large number of users, or if we
were to have a large number of updates to make.

To work around these issues, we can normalise the data. Normalisation is a
process of breaking up the data into smaller tables, and linking them together
using keys. Returning to our example, let's see how we might normalise the data
for emails:

#### Users Table

| id  | Name       | Address ID                                             | Phone Number | Date of Birth |
| --- | ---------- | ------------------------------------------------------ | ------------ | ------------- |
| 1   | John Smith | 1 Brownberrie Ln, Horsforth, Leeds, Yorkshire LS18 5HD | 01234 567890 | 01/01/1970    |
| 2   | Jane Doe   | 1 Brownberrie Ln, Horsforth, Leeds, Yorkshire LS18 5HD | 09876 543210 | 01/01/1970    |

#### Emails Table

| id  | User ID | Email Address  |
| --- | ------- | -------------- |
| a   | 1       | John@email.com |
| b   | 2       | Jane@doe.com   |

In this example, we have split the data into two tables: `users` and `emails`.
If we want to look up John's email address, we can do so by joining the two
tables together. Repeating this process for other data types will allow us to
create a more efficient database.

#### Users Table

| id  | Name       | Date of Birth |
| --- | ---------- | ------------- |
| 1   | John Smith | 01/01/1970    |
| 2   | Jane Doe   | 01/01/1970    |

#### Addresses Table

| id  | User ID | Address                                                |
| --- | ------- | ------------------------------------------------------ |
| a1  | 1       | 1 Brownberrie Ln, Horsforth, Leeds, Yorkshire LS18 5HD |
| a2  | 2       | 1 Brownberrie Ln, Horsforth, Leeds, Yorkshire LS18 5HD |

#### Phone Numbers Table

| id  | User ID | Phone Number |
| --- | ------- | ------------ |
| p1  | 1       | 01234 567890 |
| p2  | 2       | 09876 543210 |

#### Emails Table

| id  | User ID | Email Address  |
| --- | ------- | -------------- |
| e1  | 1       | John@email.com |
| e2  | 2       | Jane@doe.com   |

This gets us closer to a normalised database. We can now update John's email
address without locking the rest of the data, and we can add as many email
addresses as we like. We can also add as many addresses and phone numbers as we
like. This is a much more flexible way of storing data.

Normalisation also considers whether data is aggregated. in our example there
are three examples of this. Firstly,we have the `Address` field. This is a
single field, but it is made up of four parts. We could normalise this by
splitting it into four fields: `Street`, `City`, `County`, and `Postal Code`.
This would allow us to query the data in a more granular way. Second, we store
the full name in a single column. If we wanted to find everyone with a surname
starting with `D`, we would have to search every row in the table. If we split
the name into two columns, we could index the surname column, and search that
instead. Finally, our phone number field is a single field, but it is made up of
two parts: the area code and the number. If we split this into two fields, we
could search for everyone in a particular area code, or everyone with a
particular number, we could even add an international dialling code, and search
for everyone in a particular country.

Our final normalised database could look like this:

```mermaid
erDiagram
    users {
    TEXT 	user_id
    TEXT	name
    DATETIME	DoB
    }
    addresses {
        TEXT	id
        INT	user_id
        TEXT	street
        TEXT	city
        TEXT	county
        TEXT	postal_code
    }
    phone_numbers {
        TEXT	id
        INT	user_id
        TEXT	area_code
        TEXT	number
    }
    emails {
        INT	id
        INT	user_id
        TEXT	email
    }
    users ||--o{ addresses: has
    users ||--o{ phone_numbers: has
    users ||--o{ emails: has
```

This structure is much more flexible than our original structure. We can add as
many phone numbers, addresses, and email addresses as we like. We can also
update the data without locking the rest of the table. We can still find, we can
still return all of the information for a user, but our query would be slightly
more complex. We would have to join the tables together, and we would have to
use the `user_id` field to link the tables together. This is a small price to
pay for the flexibility that normalisation gives us.

Normalisation is an iterative process. You may find that you need to normalise
your data further as you work with it. This is normal, and is a sign that you
are getting to know your data better. You may also find that you need to
`denormalise` your data. Denormalisation is the process of combining tables back
together. This may be done to improve performance, or to simplify queries. It is
important to remember that denormalisation is a trade-off. You will lose some of
the flexibility that normalisation gives you, but you will gain performance. A
good rule of thumb is to only denormalise your data if you have a good reason to
do so. There are many ways to improve performance without the compromise of
changing the underlying data structure.

## Reading Entity Relationship Diagrams

In the previous sectionwe introduced a diagram to show how the tables were related to one another. This diagram is called an `Entity Relationship Diagram` (ERD). ERDs help us to
visualise the relationships between entities in a database. In our example, we
have four entities: `users`, `addresses`, `phone_numbers`, and `emails`. The
lines between the entities show how they are related. In our example, we have
three relationships: `users` has `addresses`, `users` has `phone_numbers`, and
`users` has `emails`. We use "crow's foot" notation to show the type of
relationship. The `o{` symbol shows that the relationship is `one-to-many`. This
means that one user can have many addresses, phone numbers, or email addresses.
The `||` symbol shows that the relationship is `one-to-one`. This means that one
user can have only one name and date of birth.



### Activity 3.1.1 How could we further normalise the data?

_20 minutes_

Looking at the Entitty Relationship Diagram above, how could we further
normalised the data? What would the benefits of this be? What would the
drawbacks be?

#### Discussion

Our current design means we can only store a `first_name` and a `last_name`.
This means we are unable to consistently store middle names, or titles. We could
add two additional columns; `title`, and `middle_name`. Our address table has
assumes that addresses have a `street`, `city`, `county`, and `postal_code`.
There's two issues with this. Firstly, we are unable to tell which `country` an
address belongs in. Second, complex addresses may have a `building_name`,
`distict`, or `suburb`. If we were wanting to print an address, we may find it
difficult to know where to add line breaks. In both cases, the more edge-cases
we attempt to cater for, the more generic our naming should be. In addition to
adding new columns, we may consider a more generic naming structure of `line_1`,
`line_2`, `line_3`, `city`, `county`, `postal_code`, `country` to keep the names
relevant to the data they store.

### Activity 3.1.2 Install a sqlite3 database browser

The activities in this section will use a sqlite3 database. There are a number
of options for working with sqlite3 databases, including command line tools and
graphical user interfaces. Here are a few options:

| Tool                                                                                                    | Notes                                                | Installation                                                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [DB Browser for SQLite](https://sqlitebrowser.org/)                                                     | Simple and easy to use GUI for working with sqlite3  | `brew install --cask db-browser-for-sqlite` (MacOS) <br> `sudo apt install sqlitebrowser` (Debian & derivatives)<br> `winget install --id=sqlitebrowser.sqlitebrowser` (Windows) |
| [sqlite3](https://www.sqlite.org/index.html)                                                            | Command line tool for working with sqlite3 databases | `brew install sqlite` (MacOS) <br> `sudo apt install sqlite3` (Debian & derivatives) <br> `winget install --id=sqlite.sqlite` (Windows)                                          |
| [sqlite (VSCode extension)](https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite) | VSCode extension for working with sqlite3 databases  | Install from VSCode marketplace                                                                                                                                                  |

If you are familiar with VSCode, the sqlite extension is a good option;
otherwise, we recommend using DB Browser for SQLite. Whilst the command line
tool is powerful, it can be more difficult to use for beginners. If you are
unable to install any of these tools, you can use the online tool
[SQLite Online](https://sqlite.org/fiddle/index.html).

## Database Objects

Before we get our hands dirty with SQL, let's take a look at some of the key
database objects that you will encounter when working with databases.

### Tables

A table is a collection of data that is organized into rows and columns. Each
row in a table represents a single record, while each column represents a
different attribute of the record. For example, a table of customers might have
columns for `name`, `address`, and `phone number`. Data is added altered or
removed in a table using DML commands. Alongside tables created by the user,
databases typically have system tables that store metadata about the database
itself. These tables allow database Administrators to manage the database and
its objects, as well as monitor performance, security, and other aspects of the
database.

### Views

A view is a virtual table that is based on the result of a SQL query. Views are
a powerful feature of SQL that allow you to create a virtual table that is based
on the result of a query. Views can be used to simplify complex queries,
restrict access to certain columns, or provide a consistent interface to the
underlying data. Views are typically used in reporting to aggregate data from
multiple tables into a single view. Because views are dynamically generated,
data in a view is not stored in the database, but is instead generated
on-the-fly when the view is queried. This means that changes to the underlying
tables will be reflected in the view.

### Indexes

An index is a data structure that is used to speed up the retrieval of data from
a table. Indexes are created on one or more columns in a table, and are used to
quickly locate rows that match a given condition. Indexes can significantly
improve the performance of queries that involve filtering or sorting data. A
good index can change a query from taking minutes to milliseconds to run.

### Stored Procedures

A stored procedure is a named block of code that performs a specific task. In
some dialects, a stored procedure may be referred to as a `function` Stored
Procedures can be used to encapsulate complex logic, improve performance, and
enforce data integrity. Stored procedures are typically used to perform common
tasks such as inserting, updating, or deleting data in a database. Stored
procedures can also be used to create reusable code that can be called from
other stored procedures or applications.

### Triggers

A trigger is a special type of stored procedure that is automatically executed
when a certain event occurs. Triggers are used to enforce data integrity,
perform auditing, or automate tasks in a database. Triggers can be defined to
act before or after an event, such as inserting, updating, or deleting data in a
table. A common use of triggers is to increment a counter or update a timestamp
when a row is inserted or updated.

### Indexes and Constraints

An index is a data structure that is used to speed up the retrieval of data from
a table. Indexes are created on one or more columns in a table, and are used to
quickly locate rows that match a given condition. Indexes can significantly
improve the performance of queries that involve filtering or sorting data.
Constraints are rules that are enforced on the data in a table. Constraints can
be used to enforce data integrity, ensure that data is consistent, and prevent
invalid data from being inserted into a table. Common constraints include
`PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, and `CHECK`.

## SQL, DML and DDL

SQL (Structured Query Language) is a powerful language that is used to query,
update, and manage data in a database. SQL is a standard language that is
supported by most relational database management systems (RDBMS). SQL is divided
into two main categories: Data Definition Language (DDL) and Data Manipulation
Language (DML). DDL commands are used to create, modify, and delete database
objects such as tables, indexes, and views. Common DDL commands include
`CREATE TABLE`, `ALTER TABLE`, and `DROP TABLE`. DML commands are used to
insert, update, delete, and retrieve data from database tables. Common DML
commands include `INSERT`, `UPDATE`, `DELETE`, and `SELECT`. In this section, we
will focus on DML commands, as they are the most commonly used commands in data
science.

### Activity 3.1.2 Load a database, and explore the tables

In the [Activity 3.1.2](3.1.2.md) directory, you will load a sample database and
explore. Load this database in your sqlite tool of choice.

The database contains the following tables:

| table name | description                                         |
| ---------- | --------------------------------------------------- |
| users      | Contains information about users                    |
| emails     | Contains email addresses for users                  |
| addresses  | Contains addresses for users                        |
| orders     | Contains orders placed by users                     |
| products   | Contains information about products                 |
| visits     | Contains information about user visits to a website |

We can query these tables by `select`ing columns from them. For example, return
all of the values in the `users` table:

```sql
SELECT  *
FROM    users;
```

![alt text](Assets/3.1/image.png)

Let's break down the SQL statement:

- `SELECT` is a DML command that is used to retrieve data
- `*` is a wildcard character that is used to select all columns
- `FROM` is a keyword that is used to specify the source of the data
- `users` is the name of the table that we are selecting data from
- `;` is a statement terminator that is used to indicate the end of the SQL
  statement. Some SQL dialects require a statement terminator, while others do
  not, it's good practice to include it.

Returning everything in a single table is not terribly useful. We can limit our
results in two ways. Firstly, we can select only certain columns from the table.
For instance to return only the first and last names of users:

```sql
SELECT  first_name
,       last_name
FROM    users;
```

Secondly, we can filter the results using a `WHERE` clause. For instance, to
return only the users who are active:

```sql
SELECT  *
FROM    users
WHERE   is_active = 1;
```

More usefully, we can combine these filters to hone in on the data we are
interested in. For instance, to return the first and last names of active users:

```sql
SELECT  first_name
,       last_name
FROM    users
WHERE   is_active = 1;
```

![alt text](Assets/3.1/image-1.png)

If we want to chain these filters together, we can use the `AND` keyword. For
instance, to return the first and last names of active users who were born after
1990:

```sql
SELECT  first_name
,       last_name
FROM    users
WHERE   is_active = 1
   AND  DoB > '1990-01-01';
```

We can create complex filtering logic by using operators such as `AND`, `OR`,
and `NOT`. For instance, to return the first and last names of users who are
active, but were not born after 1990:

```sql
SELECT  first_name
,       last_name
FROM    users
WHERE   is_active = 1
   AND  DoB <= '1990-01-01';
```

## Working with Strings

### Matching Strings

SQL provides a number of ways to match strings. The most common way is to use
`LIKE` with `wildcards`. Wildcards are special characters that are used to match
a pattern of characters. The two most common wildcards are `%` and `_`. The `%`
wildcard matches zero or more characters, while the `_` wildcard matches a
single character. For example, to return all users whose first name starts with
`J`:

```sql
SELECT  *
FROM    users
WHERE   first_name LIKE 'J%';
```

We can also combine strings using the `||` operator. For example, to return the
full name of users:

```sql
SELECT  first_name || ' ' || last_name AS full_name
FROM    users;
```

## Operators in SQL

These operators are common across all SQL dialects. The examples given are for
SQLite, they may need tweaking slightly for other dialects, for instance Oracle
databases have a special `DUAL` table that is used to return a single row of
data.

| Operator    | Description                                     | example                                   |
| ----------- | ----------------------------------------------- | ----------------------------------------- |
| +           | Addition                                        | `SELECT 1+1; /*2*/`                       |
| -           | Subtraction                                     | `SELECT 1-1; /*0*/`                       |
| \*          | Multiplication                                  | `SELECT 2*2; /*4*/`                       |
| /           | Division                                        | `SELECT 4/2; /*2*/`                       |
| %           | Modulus                                         | `SELECT 5%2; /*1*/`                       |
| =           | Equal to                                        | `SELECT 1+1 = 2; /*true*/`                |
| <>          | Not equal to                                    | `SELECT 1+1 <> 2; /*false*/`              |
| >           | Greater than                                    | `SELECT 1+1 > 2; /*false*/`               |
| <           | Less than                                       | `SELECT 1+1 < 2; /*false*/`               |
| >=          | Greater than or equal                           | `SELECT 1+1 >= 2; /*true*/`               |
| <=          | Less than or equal                              | `SELECT 1+1 <= 2; /*true*/`               |
| AND         | Logical AND (all conditions evaluate to `true`) | `SELECT 1+1 = 2 AND 1+1 = 2; /*true*/`    |
| OR          | Logical OR (any condition evalues to `true`)    | `SELECT 1+1 = 2 OR 1+1 = 3; /*true*/`     |
| NOT         | Logical NOT (negates the condition)             | `SELECT NOT 1+1 = 2; /*false*/`           |
| BETWEEN     | Between two values                              | `SELECT 1+1 BETWEEN 1 AND 3; /*true*/`    |
| IN          | In a set of values                              | `SELECT 1+1 IN (1,2,3); /*true*/`         |
| LIKE        | Search for a pattern                            | `SELECT 'hello' LIKE 'h%'; /*true*/`      |
| NOT LIKE    | Search for a pattern                            | `SELECT 'hello' NOT LIKE 'h%'; /*false*/` |
| IS NULL     | Is a NULL value                                 | `SELECT NULL IS NULL; /*true*/`           |
| IS NOT NULL | Is not a NULL value                             | `SELECT NULL IS NOT NULL; /*false*/`      |

![alt text](Assets/3.1/image-2.png)

## Aliases

As our queries get more complex, we may find that we need to refer to the same
object multiple times. For instance, if we want to return the full name of users
who have placed an order, we would need to join the `users` and `orders` tables
together.

```sql
SELECT  u.first_name || ' ' || u.last_name AS full_name
FROM    users u
    JOIN orders o
        ON u.guid = o.user_guid;
```

In this example, we have aliased the `users` table as `u` and the `orders` table
as `o`. This allows us to refer to the tables by their aliases in the query.
This can make the query easier to read and understand, particularly when working
with multiple tables. Not only do aliases make the query easier to read, they
help us avoid ambiguity. For instance, if we were to join the `users` table to
itself, we would need to use aliases to refer to the two instances of the table.

```sql
SELECT  u1.first_name || ' ' || u1.last_name AS full_name
,       u2.first_name || ' ' || u2.last_name AS full_name
FROM    users u1
    JOIN users u2
        ON u1.guid = u2.guid;
```

Using aliases in this way can help us avoid errors, and make our queries more
robust. Another benefit of aliases is that they can make our queries more
efficient. This is because the database engine can use the aliases to optimise
the query. For instance, if we were to join the `users` table to itself, the
database engine could use the aliases to avoid scanning the table twice. This
can result in a significant performance improvement, particularly we are using a
complex query on a large dataset.

## What constitutes a unique row?

In relational databases, each row in a table represents a unique record. It is
not always obvious what makes a row unique in a table. Guessing what makes a row
unique could be an option, but if the database logic doesn't match your guess,
you will likely find that your query works in unexpected ways, particularly if
the data has quality issues, or is changing over time. These issues will be
compounded when you start joining tables together.

In order to ensure that each row is unique, databases use a primary key to
identify each row in a table. A primary key is a column or combination of
columns that uniquely identifies each row in a table. Primary keys are used to
enforce data integrity, ensure that each row is unique, and provide a consistent
way to reference rows in a table. In the example database, the `users` table has
a primary key column called `guid`, which is used to uniquely identify each
user. How do we find out the primary key/s for a table? If you are using db
browser, you can find this information in the `DB Schema` tab.

![Database Schema](Assets/3.1/image-3.png) Most DBMS (Database Management
Systems) will have similar functionality, but it can be useful to be able to
query the database directly. The following query will return the primary key for
each table in a database:

```sql
SELECT  m.name  AS tableName,
        p.type || CASE
                    WHEN p.pk = 1
                    THEN ' (PK)'
                    ELSE ''
                  END
                AS data_type,
        p.name  AS columnName,
        p.cid   AS columnID
FROM    sqlite_master m
    LEFT OUTER JOIN pragma_table_info((m.name)) p
        ON m.name <> p.name
WHERE   m.name NOT LIKE 'ix_%'
	AND m.name NOT LIKE  'sqlite_%'
ORDER BY tableName, p.cid
;
```

This query is more complex than the ones we have seen so far. Let's break it
down:

| Part of the query                                                      | Description                                                                               |
| ---------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `SELECT`                                                               | The command that tells the database what to return                                        |
| `m.name AS tableName`                                                  | The name of the table `alias`ed as `tableName`                                            |
| `p.type \|\| CASE WHEN p.pk = 1 THEN ' (PK)' ELSE '' END AS data_type` | This line returns the value of `p.type` and appends ` (PK)` if the value of `p.pk` is `1` |
| `p.name AS columnName`                                                 | The name of the column `alias`ed as `columnName`                                          |
| `p.cid`                                                                | The column ID `alias`ed as `columnID`                                                     |
| `FROM sqlite_master m`                                                 | The table that we are selecting data from, `alias`ed as `m`                               |
| `LEFT OUTER JOIN pragma_table_info((m.name)) p`                        | The table that we are joining to, `alias`ed as `p`                                        |
| `ON m.name <> p.name`                                                  | The condition that the two tables are joined on                                           |
| `WHERE m.name NOT LIKE 'ix_%'`                                         | The condition that the table name does not start with `ix_`                               |
| `AND m.name NOT LIKE 'sqlite_%'`                                       | The condition that the table name does not start with `sqlite_`                           |
| `ORDER BY tableName, p.cid`                                            | The order that the results are returned in                                                |

## Steps

```mermaid
erDiagram
    users {
    TEXT 	guid
    DATETIME	DoB
    TEXT	first_name
    TEXT	last_name
    DATETIME	account_created
    INTEGER	is_active
    }
    emails {
        TEXT	user_guid
        TEXT	email
        TEXT	type
        INTEGER	verified
    }
    addresses {
        TEXT	user_guid
        TEXT	address
        TEXT	city
        TEXT	county
        TEXT	postal_code
    }
    orders {
        TEXT	order_id
        TEXT	user_guid
        TEXT	product_guid
        TIMESTAMP	order_datetime
    }
    products {
        TEXT	product_guid
        TEXT	product_name
        REAL	price
        TEXT	category
    }
    visits {
        TEXT	user_guid
        TIMESTAMP	visit_datetime
        INTEGER	distinct_page_views
        INTEGER	time_on_site
        TEXT	source
    }
    users ||--|| emails: has
    users ||--|| addresses: has
    users ||--o{ visits : makes
    users ||--o{ orders : places
    orders ||--o{ products : contains
```

---

## Useful links

https://www.linkedin.com/learning/sql-essential-training-20685933/

https://mystery.knightlab.com/
